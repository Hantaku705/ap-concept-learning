# アーキテクチャ設計

詳細なフロー図と設計思想。

## 目次

- [全体アーキテクチャ](#全体アーキテクチャ)
- [処理ステップ詳細](#処理ステップ詳細)
- [並列処理設計](#並列処理設計)
- [ストリーミング設計](#ストリーミング設計)
- [エラーハンドリング](#エラーハンドリング)

---

## 全体アーキテクチャ

### システム構成図

```
┌─────────────────────────────────────────────────────────────────┐
│                        クライアント                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  ChatInput → URL入力 → EventSource接続                   │   │
│  │                     ↓                                     │   │
│  │  AnalysisProgress ← SSE受信 ← MessageItem表示            │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────┬───────────────────────────────────────────┘
                      │ POST /api/chat
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                        サーバー                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  route.ts                                                 │   │
│  │  ├─ URL種別判定                                           │   │
│  │  ├─ analyzeTikTokProfile() ←────────────────────────┐    │   │
│  │  │   ├─ getTikTokUserVideos()                       │    │   │
│  │  │   ├─ calculateAccountStats()                     │    │   │
│  │  │   ├─ analyzeVideosInBatches()                    │    │   │
│  │  │   │   ├─ downloadTikTokVideo()                   │    │   │
│  │  │   │   └─ analyzeVideoWithGemini()                │    │   │
│  │  │   └─ generateReport()                            │    │   │
│  │  └─ model.sendMessageStream()                       │    │   │
│  └─────────────────────────────────────────────────────┼────┘   │
└─────────────────────────────────────────────────────────┼───────┘
                                                          │
                      ┌───────────────────────────────────┘
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                      外部API                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │ RapidAPI     │  │ RapidAPI     │  │ Google Generative AI │  │
│  │ tiktok-api23 │  │ downloader   │  │ Gemini 2.0 Flash     │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 処理ステップ詳細

### Step 1: URL判定

```
入力: "https://www.tiktok.com/@luana.beauty.2nd?lang=en"
      ↓
┌─────────────────────────────────────────┐
│ isTikTokProfileUrl(url)                 │
│ - 正規表現: tiktok.com/@[username]      │
│ - 単一動画URLとの区別                    │
└─────────────────────────────────────────┘
      ↓
出力: true → プロフィール分析フローへ
      false → 通常チャットまたは単一動画分析へ
```

### Step 2: プロフィール情報取得

```
┌─────────────────────────────────────────────────────────────┐
│ getTikTokUserVideos(url, count=10)                          │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┴─────────────┐
        ▼                           ▼
┌───────────────────┐       ┌───────────────────┐
│ API Call #1       │       │ API Call #2       │
│ /api/user/info    │   →   │ /api/user/posts   │
│ uniqueId取得      │       │ secUid使用        │
│                   │       │ 10件取得          │
└───────────────────┘       └───────────────────┘
        │                           │
        └─────────────┬─────────────┘
                      ▼
              TikTokUserVideos {
                username: string
                videos: [{
                  id, url, desc,
                  stats: { playCount, likeCount, ... },
                  thumbnail
                }]
              }
```

### Step 3: 統計計算

```
┌─────────────────────────────────────────────────────────────┐
│ calculateAccountStats(videos)                                │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ 計算項目:                                                    │
│                                                              │
│ ■ エンゲージメント率                                         │
│   LVR = (総いいね / 総再生) × 100                           │
│   CVR = (総コメント / 総再生) × 100                         │
│   SVR = (総シェア / 総再生) × 100                           │
│   保存率 = (総保存 / 総再生) × 100                          │
│                                                              │
│ ■ パフォーマンス分布                                         │
│   最大再生数 / 最小再生数 / 中央値 / 標準偏差               │
│   バズ率 = (平均の2倍超の動画数 / 総数) × 100               │
│                                                              │
│ ■ 投稿頻度                                                   │
│   平均投稿間隔（日）                                         │
│   カテゴリ: 毎日 / 2日1回 / 週1回 / 不定期                  │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
              AccountStats {
                totalViews, totalLikes,
                lvr, cvr, svr, saveRate,
                maxViews, minViews, median,
                buzzRate, postingFrequency
              }
```

### Step 4: 動画分析（バッチ並列）

```
┌─────────────────────────────────────────────────────────────┐
│ analyzeVideosInBatches(videos, batchSize=5)                 │
└─────────────────────┬───────────────────────────────────────┘
                      │
     ┌────────────────┴────────────────┐
     │        Batch 1 (5件並列)         │
     │  ┌─────┬─────┬─────┬─────┬─────┐│
     │  │ V1  │ V2  │ V3  │ V4  │ V5  ││
     │  └──┬──┴──┬──┴──┬──┴──┬──┴──┬──┘│
     │     │     │     │     │     │   │
     │     └─────┴─────┼─────┴─────┘   │
     │                 │               │
     │         Promise.all()           │
     └────────────────┬────────────────┘
                      │
                      ▼ 進捗更新
     ┌────────────────┴────────────────┐
     │        Batch 2 (5件並列)         │
     │  ┌─────┬─────┬─────┬─────┬─────┐│
     │  │ V6  │ V7  │ V8  │ V9  │ V10 ││
     │  └─────┴─────┴─────┴─────┴─────┘│
     └────────────────┬────────────────┘
                      │
                      ▼
              VideoAnalysisResult[] {
                videoId, analysis, error?
              }
```

#### 各動画の処理フロー

```
┌───────────────────────────────────────────────────────────────┐
│ analyzeVideo(video)                                           │
└─────────────────────┬─────────────────────────────────────────┘
                      │
        ┌─────────────┴─────────────┐
        ▼                           │
┌───────────────────┐               │
│ downloadTikTok    │               │
│ Video(url)        │               │
│                   │               │
│ RapidAPI →        │               │
│ videoUrl取得 →    │               │
│ fetch → Buffer    │               │
└─────────┬─────────┘               │
          │                         │
          ▼                         │
┌───────────────────┐               │
│ analyzeVideoWith  │               │
│ Gemini(buffer)    │               │
│                   │               │
│ 1. 一時ファイル保存 │               │
│ 2. FileManager    │               │
│    .uploadFile()  │               │
│ 3. state確認      │               │
│    (PROCESSING→   │               │
│     ACTIVE)       │               │
│ 4. generate       │               │
│    Content()      │               │
└─────────┬─────────┘               │
          │                         │
          ▼                         │
  Markdown形式の分析結果            │
  - 動画内容要約                    │
  - タイムライン                    │
  - バズ要因分析                    │
  - 改善提案                        │
          │                         │
          └─────────────────────────┘
```

### Step 5: レポート生成

```
┌─────────────────────────────────────────────────────────────┐
│ generateReport(stats, analysisResults, videos)               │
└─────────────────────┬───────────────────────────────────────┘
                      │
     ┌────────────────┼────────────────┬────────────────┐
     ▼                ▼                ▼                ▼
┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
│定量レポート│   │定性プロンプト│   │ランキング│   │動画JSON │
│          │   │          │   │          │   │          │
│• 基本指標 │   │• フック分析│   │• Top 3   │   │• 全動画  │
│• ER詳細  │   │• 構成分析 │   │• Worst 1 │   │  データ  │
│• 業界比較 │   │• CTA分析  │   │• スコア  │   │• UI表示用│
│• 分布   │   │• 改善提案 │   │          │   │          │
└──────────┘   └──────────┘   └──────────┘   └──────────┘
     │                │                │                │
     └────────────────┴────────────────┴────────────────┘
                      │
                      ▼
              最終レポート（Markdown）
              + videoListJson（UI用）
```

### Step 6: AI応答生成

```
┌─────────────────────────────────────────────────────────────┐
│ model.startChat({                                            │
│   history: conversationHistory,                              │
│   systemInstruction: systemPrompt + analysisContext,         │
│   generationConfig: { temperature: 0.8, maxTokens: 4096 }   │
│ }).sendMessageStream(userInput)                              │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
              ストリーミング出力
              chunk1 → chunk2 → chunk3 → ...
                      │
                      ▼
              SSE: data: {"content": "..."}\n\n
```

---

## 並列処理設計

### なぜ5件ずつか

```
┌─────────────────────────────────────────────────────────────┐
│ 並列数の設計判断                                              │
│                                                              │
│ ■ 制約要因                                                   │
│   1. RapidAPI レート制限（同時リクエスト数）                 │
│   2. Gemini API レート制限（RPM/TPM）                        │
│   3. Vercel Function メモリ制限                              │
│   4. ネットワーク帯域（動画ダウンロード）                    │
│                                                              │
│ ■ 5件が最適な理由                                            │
│   - API制限に収まる                                          │
│   - メモリ使用量が安定（動画は1件2-4MB）                     │
│   - タイムアウトリスク低減                                   │
│   - 進捗表示が適切な粒度                                     │
│                                                              │
│ ■ 調整可能                                                   │
│   - 高性能環境: batchSize=10                                 │
│   - 制限厳しい環境: batchSize=3                              │
└─────────────────────────────────────────────────────────────┘
```

### タイムライン図

```
時間 →
[0s]         [10s]        [20s]        [30s]        [40s]
│            │            │            │            │
├─ Profile ──┤            │            │            │
│  取得      │            │            │            │
│            ├─ Batch 1 ──────────────┤            │
│            │  (5件並列)              │            │
│            │  download + analyze    │            │
│            │                        ├─ Batch 2 ──────────┤
│            │                        │  (5件並列)          │
│            │                        │                    │
│                                                          ├─ Report ─┤
│                                                          │  生成     │
│                                                          │          │
[完了: ~50秒]                                              [~90秒]
```

---

## ストリーミング設計

### SSEメッセージ形式

```typescript
// 進捗更新
{ type: "progress", stage: "動画分析中", percent: 30, current: 3, total: 10 }

// Creator区切り（複数Creator分析時）
{ type: "creator_start", creatorId: "doshirouto", creatorName: "ど素人ホテル" }
{ type: "creator_end", creatorId: "doshirouto" }

// 動画一覧（UI用）
{ type: "video_list", videos: [...] }

// おすすめ質問
{ type: "suggested_questions", questions: [...] }

// 通常のチャット応答（OpenAI互換形式）
{ choices: [{ delta: { content: "..." } }] }

// 終了
[DONE]
```

### クライアント側処理

```typescript
const eventSource = new EventSource("/api/chat");

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);

  switch (data.type) {
    case "progress":
      updateProgressBar(data.percent);
      break;
    case "video_list":
      renderVideoTable(data.videos);
      break;
    default:
      // 通常のチャット応答
      appendMessage(data.choices[0].delta.content);
  }
};
```

---

## エラーハンドリング

### エラー階層

```
┌─────────────────────────────────────────────────────────────┐
│ Level 1: 致命的エラー（処理中断）                            │
│   - API認証エラー                                            │
│   - ネットワーク障害                                         │
│   → ユーザーにエラーメッセージ表示                           │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ Level 2: 部分エラー（処理継続）                              │
│   - 個別動画のダウンロード失敗                               │
│   - 個別動画のAI分析失敗                                     │
│   → 該当動画にerrorフラグ、他の動画は処理継続                │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ Level 3: 警告（ログのみ）                                    │
│   - 一部メトリクス取得失敗                                   │
│   - おすすめ質問生成失敗                                     │
│   → デフォルト値で補完、処理継続                             │
└─────────────────────────────────────────────────────────────┘
```

### リトライ戦略

```typescript
// タイムアウト設定
const TIMEOUTS = {
  profileFetch: 30_000, // 30秒
  videoDownload: 60_000, // 60秒
  geminiAnalysis: 120_000, // 120秒
};

// リトライ回数
const MAX_RETRIES = 2;

// 指数バックオフ
const getRetryDelay = (attempt: number) =>
  Math.min(1000 * Math.pow(2, attempt), 10000);
```

---

## 設計原則

### 1. フェイルソフト

個別の失敗がシステム全体を止めない設計。

```
10動画中2動画が失敗
  ↓
8動画の分析結果でレポート生成
  ↓
失敗した動画は「分析失敗」と明示
```

### 2. プログレッシブエンハンスメント

最低限の機能は必ず提供。

```
Gemini分析失敗
  ↓
統計データのみでレポート生成
  ↓
「AI分析は利用できませんでした」と表示
```

### 3. ユーザー体験優先

待ち時間を体感的に短くする工夫。

```
- 進捗バーでリアルタイム表示
- 完了した動画から順次表示
- 分析中でもUIは操作可能
```
