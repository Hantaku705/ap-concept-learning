import { NextResponse } from 'next/server'
import { readFileSync, existsSync, readdirSync } from 'fs'
import { join } from 'path'

const PROJECT_DIR = join(process.cwd(), '..')

interface AgentStatus {
  name: string
  status: 'active' | 'working' | 'idle' | 'error' | 'offline'
  currentTask: string
  progress: number | null
}

interface Task {
  id: string
  command: string
  status: 'pending' | 'in_progress' | 'completed' | 'failed'
  duration: string
}

interface Skill {
  id: string
  trigger: string
  successRate: number
  usage: number
}

function parseDashboardMarkdown(): {
  status: 'running' | 'stopped'
  agents: AgentStatus[]
  tasks: Task[]
  systemInfo: {
    started: string
    uptime: string
    tasksCompleted: number
    skillsGenerated: number
  }
  lastUpdated: string
} {
  const dashboardPath = join(PROJECT_DIR, 'dashboard.md')

  if (!existsSync(dashboardPath)) {
    return getDefaultData()
  }

  try {
    const content = readFileSync(dashboardPath, 'utf-8')

    // Parse status
    const statusMatch = content.match(/## Status: (ðŸŸ¢ Running|ðŸ”´ Stopped)/)
    const status = statusMatch?.[1]?.includes('Running') ? 'running' : 'stopped'

    // Parse agents table
    const agents: AgentStatus[] = []
    const agentTableMatch = content.match(/\| Agent \| Status \| Current Task \| Progress \|[\s\S]*?(?=\n\n|\n##)/)?.[0]

    if (agentTableMatch) {
      const rows = agentTableMatch.split('\n').slice(2) // Skip header and separator
      for (const row of rows) {
        const cells = row.split('|').map(c => c.trim()).filter(Boolean)
        if (cells.length >= 4) {
          const statusMap: Record<string, AgentStatus['status']> = {
            'ðŸŸ¢ Active': 'active',
            'ðŸŸ¡ Working': 'working',
            'ðŸŸ¡ Idle': 'idle',
            'ðŸ”´ Error': 'error',
            'âšª Offline': 'offline',
          }

          agents.push({
            name: cells[0],
            status: statusMap[cells[1]] || 'offline',
            currentTask: cells[2] || '-',
            progress: cells[3] && cells[3] !== '-' ? parseInt(cells[3]) : null,
          })
        }
      }
    }

    // Parse tasks table
    const tasks: Task[] = []
    const taskTableMatch = content.match(/## Recent Tasks[\s\S]*?\| Task ID \| Command \| Status \| Duration \|[\s\S]*?(?=\n\n|\n##)/)?.[0]

    if (taskTableMatch) {
      const rows = taskTableMatch.split('\n').filter(r => r.startsWith('|')).slice(2)
      for (const row of rows) {
        const cells = row.split('|').map(c => c.trim()).filter(Boolean)
        if (cells.length >= 4 && cells[0] !== '-') {
          const statusMap: Record<string, Task['status']> = {
            'âœ… Completed': 'completed',
            'âŒ Failed': 'failed',
            'â³ In Progress': 'in_progress',
            'â—‹ Pending': 'pending',
          }

          tasks.push({
            id: cells[0],
            command: cells[1],
            status: statusMap[cells[2]] || 'pending',
            duration: cells[3],
          })
        }
      }
    }

    // Parse system info
    const startedMatch = content.match(/\*\*Started\*\*: (.+)/)
    const uptimeMatch = content.match(/\*\*Uptime\*\*: (.+)/)
    const tasksCompletedMatch = content.match(/\*\*Tasks Completed\*\*: (\d+)/)
    const skillsGeneratedMatch = content.match(/\*\*Skills Generated\*\*: (\d+)/)
    const lastUpdatedMatch = content.match(/## Last Updated: (.+)/)

    return {
      status,
      agents: agents.length > 0 ? agents : getDefaultAgents(),
      tasks,
      systemInfo: {
        started: startedMatch?.[1] || 'Not started',
        uptime: uptimeMatch?.[1] || '-',
        tasksCompleted: parseInt(tasksCompletedMatch?.[1] || '0'),
        skillsGenerated: parseInt(skillsGeneratedMatch?.[1] || '0'),
      },
      lastUpdated: lastUpdatedMatch?.[1] || new Date().toISOString(),
    }
  } catch (error) {
    console.error('Error parsing dashboard.md:', error)
    return getDefaultData()
  }
}

function getAutoGeneratedSkills(): Skill[] {
  const skillsDir = join(PROJECT_DIR, 'skills', 'auto-generated')

  if (!existsSync(skillsDir)) {
    return []
  }

  const skills: Skill[] = []

  try {
    const files = readdirSync(skillsDir).filter(f => f.endsWith('.yaml'))

    for (const file of files) {
      const content = readFileSync(join(skillsDir, file), 'utf-8')
      const idMatch = content.match(/skill_id: (.+)/)
      const triggerMatch = content.match(/trigger: "?(.+)"?/)
      const successRateMatch = content.match(/success_rate: ([\d.]+)/)
      const usageCountMatch = content.match(/usage_count: (\d+)/)

      if (idMatch) {
        skills.push({
          id: idMatch[1].trim(),
          trigger: triggerMatch?.[1]?.replace(/"/g, '').split('|')[0] || '-',
          successRate: parseFloat(successRateMatch?.[1] || '0'),
          usage: parseInt(usageCountMatch?.[1] || '0'),
        })
      }
    }
  } catch (error) {
    console.error('Error reading skills:', error)
  }

  return skills
}

function getDefaultAgents(): AgentStatus[] {
  return [
    { name: 'Orchestrator', status: 'offline', currentTask: '-', progress: null },
    { name: 'Coordinator', status: 'offline', currentTask: '-', progress: null },
    ...Array.from({ length: 8 }, (_, i) => ({
      name: `SubAgent-${i + 1}`,
      status: 'offline' as const,
      currentTask: '-',
      progress: null,
    })),
  ]
}

function getDefaultData() {
  return {
    status: 'stopped' as const,
    agents: getDefaultAgents(),
    tasks: [],
    systemInfo: {
      started: 'Not started',
      uptime: '-',
      tasksCompleted: 0,
      skillsGenerated: 0,
    },
    lastUpdated: new Date().toISOString(),
  }
}

export async function GET() {
  const dashboardData = parseDashboardMarkdown()
  const skills = getAutoGeneratedSkills()

  return NextResponse.json({
    ...dashboardData,
    skills,
    lastUpdated: new Date().toISOString(),
  })
}
